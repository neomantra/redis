-- redis.lua
--
-- Redis executes this Lua script to establish the 
-- Lua environment for EVAL/EVALSHA commands.
--
-- It must return a Lua table, which is used as the function 
-- environment.
--


-------------------------------------------------------------------------------
-- Create the function environment.
--
-- The list is generated by:
--    luajit -e 'for k,v in pairs(_G) do print(k,v) end' | awk '{print "    "$1" = "$1","}' | egrep -v 'jit|ffi'
-- and then curated for a decent sandbox.
--

local fenv = {
    -- stock sandbox
    coroutine = coroutine,
    assert = assert,
    tostring = tostring,
    tonumber = tonumber,
    --io = io,
    --rawget = rawget,
    xpcall = xpcall,
    ipairs = ipairs,
    print = print,
    pcall = pcall,
    gcinfo = gcinfo,
    --module = module,
    --setfenv = setfenv,
    pairs = pairs,
    --package = package,
    error = error,
    --debug = debug,
    --loadfile = loadfile,
    --rawequal = rawequal,
    --loadstring = loadstring,
    --rawset = rawset,
    unpack = unpack,
    table = table,
    --require = require,
    _VERSION = _VERSION,
    newproxy = newproxy,
    --collectgarbage = collectgarbage,
    --dofile = dofile,
    next = next,
    math = math,
    --load = load,
    --os = os,
    --_G = _G,
    select = select,
    string = string,
    type = type,
    --getmetatable = getmetatable,
    --getfenv = getfenv,
    --setmetatable = setmetatable,
}

fenv.bit = require 'bit'

-- fenv.ffi = require 'ffi'
-- fenv.jit = require 'jit'

fenv.redis = {
    LOG_DEBUG = redis.LOG_DEBUG,
    LOG_VERBOSE = redis.LOG_VERBOSE,
    LOG_NOTICE = redis.LOG_NOTICE,
    LOG_WARNING = redis.LOG_WARNING,
    log = redis.log,
    error_reply = redis.error_reply,
    status_reply = redis.status_reply,
    pcall = redis.pcall,
    call = redis.call,
    sha1hex = redis.sha1hex,
}


--local jit_verbose = require 'jit/v'
--jit_verbose.on('foo_verb.txt')

--local jit_dump = require 'jit/dump'
--jit_dump.on(nil,'foo_dump.txt')

--redis.makeTableReadOnly( fenv )

return fenv
